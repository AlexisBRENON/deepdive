deepdive {

  #pipeline.run: "layer1_0"
  #pipeline.pipelines.layer0_1: ["ext_variables1_layer0"]
  pipeline.pipelines.layer1_0: ["ext_variables0_layer1"]

  db.default {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME} # "
    user: ${PGUSER}
    password: ${PGPASSWORD}
  }

  schema.variables {
    variables0_layer0.value: Real
    variables0_layer1.value: Real
    variables0_layer_lr.value: Real
  }

  extraction.extractors: {
    ext_images {
      input: """SELECT 0"""
      output_relation: "images"
      udf: "python "${APP_HOME}"/udf/load_images.py"  # 55s # try "pypy ..."
      #udf: "python "${APP_HOME}"/udf/load_images_tsv.py"   #43s
      before: ${APP_HOME}"/udf/before_images.sh"
      parallelism: 1
      #style: "tsv_extractor"
    }

    ext_variables0_layer0 {
      input: """SELECT * from images"""
      output_relation: "variables0_layer0"
      udf: "python "${APP_HOME}"/udf/variables0_layer0.py"
      before: ${APP_HOME}"/udf/before_variables0_layer0.sh"
      parallelism: 5  #5->100s
      dependencies: ["ext_images"]
    }

    ext_variables1_layer0 {
      input: """SELECT image_id, fid, array_agg(x) as xs, array_agg(y) as ys, array_agg(value) as values
                FROM variables0_layer0 GROUP BY image_id,fid"""
      output_relation: "variables1_layer0"
      udf: "python "${APP_HOME}"/udf/variables1_layer0.py"
      before: ${APP_HOME}"/udf/before_variables1_layer0.sh"
      parallelism: 5  #5->400s
      dependencies: ["ext_variables0_layer0"]
    }

    ext_variables0_layer1 {
      input: """SELECT image_id,Bx,By,fid
                FROM variables1_layer0"""
      output_relation: "variables0_layer1"
      udf: "python "${APP_HOME}"/udf/variables0_layer1.py"
      before: ${APP_HOME}"/udf/before_variables0_layer1.sh"
      parallelism: 5  #5->151s
      dependencies: ["ext_variables1_layer0"]
    }

    ext_variables0_layer_lr{
      input: """SELECT images.image_id AS image_id,x,y,fid,label
                FROM variables0_layer1, images
                WHERE images.image_id=variables0_layer1.image_id"""
      output_relation: "variables0_layer_lr"
      udf: "python "${APP_HOME}"/udf/variables0_layer_lr.py"
      before: ${APP_HOME}"/udf/before_variables0_layer_lr.sh"
      parallelism: 5  
      dependencies: ["ext_variables0_layer1"]
    }
  }


  inference.factors: {
    conv_layer0 {
      input_query: """
        SELECT  array_agg(v00.id) AS "variables0_layer0.ids",
                array_agg(v00.value) AS "variables0_layer0.values",
                v01.id AS "variables0_layer1.id",
                v01.value AS "variables0_layer1.value", 
                v00.fid
          FROM  variables0_layer0 v00,
                variables0_layer1 v01,
                (SELECT v10.id,v10.image_id,
                        v10.fid,v10.Bx,v10.By,
                        unnest(prev_ids) AS prev_id,
                        generate_subscripts(prev_ids, 1) AS pos
                 FROM   variables1_layer0 AS v10) AS v10_unnested
         WHERE  v00.image_id=v10_unnested.image_id And
                v00.fid=v10_unnested.fid And
                v00.vector_id=v10_unnested.prev_id And
                v10_unnested.image_id=v01.image_id And
                v10_unnested.fid=v01.fid And
                v10_unnested.Bx=v01.x And
                v10_unnested.By=v01.y
      GROUP BY  v01.id, v01.value, v00.fid;
        """
      function: "Conv(variables0_layer0.values, variables0_layer1.value)"
      weight: "?(fid)[9]"  
    }

    softmax0 {
      input_query: """
        SELECT  v01.id AS "variables0_layer1.id",
                v01.value AS "variables0_layer1.value",
                v0lr.id AS "variables0_layer_lr.id",
                v0lr.value AS "variables0_layer_lr.value"
          FROM  variables0_layer1 v01, 
                variables0_layer_lr v0lr
          WHERE v0lr.class=0 And
                v0lr.image_id=v01.image_id And
                v0lr.x=v01.x And
                v0lr.y=v01.y And
                v0lr.fid=v01.fid 
        """
      function : "softmax(variables0_layer_lr.value,variables0_layer1.value)"
      weight   : "?"
    }
    softmax1 {
      input_query: """
        SELECT  v01.id AS "variables0_layer1.id",
                v01.value AS "variables0_layer1.value",
                v0lr.id AS "variables0_layer_lr.id",
                v0lr.value AS "variables0_layer_lr.value"
          FROM  variables0_layer1 v01, 
                variables0_layer_lr v0lr
          WHERE v0lr.class=1 And
                v0lr.image_id=v01.image_id And
                v0lr.x=v01.x And
                v0lr.y=v01.y And
                v0lr.fid=v01.fid 
        """
      function : "softmax(variables0_layer_lr.value,variables0_layer1.value)"
      weight   : "?"
    }

    logisticRegression {
      input_query: """
        SELECT  array_agg(v0lr.id) AS "variables0_layer_lr.ids",
                array_agg(v0lr.value) AS "variables0_layer_lr.values",
                v0lr.vector_id As "vector_id"
          FROM  variables0_layer_lr v0lr
      GROUP BY  v0lr.vector_id
        """
      function : "likelihood(variables0_layer_lr.values)"
      weight   : "0[2]"
    }
  }

  # Specify a holdout fraction
  calibration.holdout_fraction: 0.0

}








